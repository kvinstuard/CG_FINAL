<style>
    body {
      margin: 0;
    }
  </style>
  
  <script
    async
    src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
  ></script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

    //Estamos desarrollando dentro del html para poder utilizar cdn
  
    const scene = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    )


  
    const renderer = new THREE.WebGLRenderer()
    renderer.shadowMap.enabled = true //shadows
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement)
  
    const controls = new OrbitControls(camera, renderer.domElement)
    
    //La clase capsule hereda de mesh
    class Box extends THREE.Mesh {
      constructor({width, height, depth, color = '#2B2E4A', 
      velocity ={
        x: 0,
        y: 0,
        z: 0
      },
      position = {
        x: 0,
        y: 0,
        z: 0
      }

    }){
        super(
        new THREE.BoxGeometry( width, height, depth ),
        new THREE.MeshStandardMaterial({color})
        )
        this.width = width
        this.height = height
        this.depth = depth

        this.position.set(position.x, position.y, position.z)
        //Usados para poder trabajar con la gravedad y colisiones.
        
        this.right = this.position.x + this.width / 2
        this.left = this.position.x - this.width / 2

        this.botton = this.position.y - this.height /2
        this.top = this.position.y + this.height / 2

        this.front = this.position.z + this.depth /2
        this.back = this.position.z - this.depth / 2
        //La velocidad por defecto mantiene a los objetos estaticos
        this.velocity = velocity
        this.gravity = -0.005
      }
      updateSides(){
        this.right = this.position.x + this.width / 2
        this.left = this.position.x - this.width / 2

        this.botton = this.position.y - this.height /2
        this.top = this.position.y + this.height / 2

        this.front = this.position.z + this.depth /2
        this.back = this.position.z - this.depth / 2
      }

      update(ground){ 
        this.updateSides()

        this.position.x += this.velocity.x
        this.position.z += this.velocity.z

        //detectando colisiones
        const zCollision = this.front >= ground.back && this.back <= ground.front
        const xCollision = this.right >= ground.left && this.left <= ground.right
        
        if(zCollision && xCollision){
          console.log('colap')
        }
        this.applyGravity()
      }

      applyGravity(){
        this.velocity.y += this.gravity //gravedad
      
        //El cubo se rebota al llegar al suelo
        if(this.botton + this.velocity.y <= ground.top){
          this.velocity.y *= 0.8 //simulando friccioon
          this.velocity.y = -this.velocity.y
        }
        else this.position.y += this.velocity.y
      }
    }
    
    //Definiendo el cubo
    const cube = new Box({
      width: 1,
      height: 1,
      depth: 1,
      velocity: {
        x: 0,
        y:-0.01,
        z: 0
      }
    })
    cube.castShadow = true //produce sombras

    scene.add(cube)

    //DEFINIR ESTILOS COMO HALLOWEN 
    
    //Definiendo el suelo
    const ground = new Box({
      width: 5,
      height: 0.5,
      depth: 10,
      color: '#E84545',
      position: {
        x: 0,
        y: -2,
        z: 0
      }
    })
    //Posicionandolo debajo del objeto cubo
    ground.receiveShadow = true //diciendo que objeto recibe la sombra
    scene.add(ground)

    //AÃ±adiento luz a la escena -> atributos:color, intensidad
    const light = new THREE.DirectionalLight(0xffffff, 1)
    //Ubicando la luz mas cerca del espectador
    light.position.y = 3
    light.position.z = 2
    light.castShadow = true //la luz produce sombra
    scene.add(light)
    camera.position.z = 5



    const keys = {
      a: {
        pressed: false
      },
      d: {
        pressed: false
      },
      s: {
        pressed: false
      },
      w: {
        pressed: false
      }
    }
    //movimientos on pressed
    window.addEventListener('keydown', (event)=>{
      switch(event.code){
        case 'KeyA':
          keys.a.pressed = true
          break
        case 'KeyD':
          keys.d.pressed = true
          break
        case 'KeyS':
          keys.s.pressed = true
          break
        case 'KeyW':
          keys.w.pressed = true
          break
      }
    })
    //cuando se suelta la tecla
    window.addEventListener('keyup', (event)=>{
      switch(event.code){
        case 'KeyA':
          keys.a.pressed = false
          break
        case 'KeyD':
          keys.d.pressed = false
          break
        case 'KeyS':
          keys.s.pressed = false
          break
        case 'KeyW':
          keys.w.pressed = false
          break
      }
    })

  
    function animate() {
      requestAnimationFrame(animate)
      renderer.render(scene, camera)

      //movimiento
      cube.velocity.x = 0
      cube.velocity.z = 0
      if(keys.a.pressed) cube.velocity.x = -0.01
      else if(keys.d.pressed) cube.velocity.x = 0.01

      if(keys.s.pressed) cube.velocity.z = 0.01
      else if(keys.w.pressed) cube.velocity.z = -0.01
      


      cube.update(ground)
    }
    animate()
  </script>